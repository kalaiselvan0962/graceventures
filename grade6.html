<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Falling Blocks — Browser Version</title>
  <style>
    /* Simple centered layout */
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    #game {
      background: #000;
      box-shadow: 0 8px 30px rgba(0,0,0,0.7);
      border-radius: 8px;
      overflow: hidden;
    }
    .topbar {
      height: 40px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 12px;
      background:#0b0b0b;
      color:#ddd;
      font-size:14px;
      box-sizing:border-box;
    }
    .hint { opacity: 0.8; font-size:13px; }
    canvas { display:block; background:#000; }
    .credits { padding:8px; text-align:center; font-size:12px; color:#aaa; }
  </style>
</head>
<body>
  <div id="game" role="application">
    <div class="topbar">
      <div>Falling Blocks</div>
      <div class="hint">← → move · ↓ faster · Space to hard-drop</div>
    </div>
    <canvas id="canvas"></canvas>
    <div class="credits">Copy-paste this file and open in a browser</div>
  </div>

  <script>
  // ----- Config -----
  const ROWS = 10;
  const COLS = 10;
  const BLOCK_SIZE = 40; // px
  const TOP_MARGIN = 40; // matches topbar height
  const WIDTH = COLS * BLOCK_SIZE;
  const HEIGHT = ROWS * BLOCK_SIZE;

  // Gravity timings (ms)
  const FALL_INTERVAL = 600;    // base fall every 600ms
  const FAST_FALL_INTERVAL = 60; // when pressing down
  const MOVE_COOLDOWN = 100;     // ms between lateral moves while holding key

  // Colors
  const GRID_LINE_COLOR = '#282828';
  const BLOCK_COLOR = '#c0392b';
  const OCCUPIED_COLOR = '#2ecc71';

  // ----- Setup canvas -----
  const canvas = document.getElementById('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  const ctx = canvas.getContext('2d');

  // ----- Game state -----
  // grid[r][c] = false or color string for occupied cells
  const grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => null));

  class Block {
    constructor(col= Math.floor(Math.random() * COLS), row=0, color=BLOCK_COLOR) {
      this.col = col;
      this.row = row;
      this.color = color;
    }

    draw() {
      const x = this.col * BLOCK_SIZE;
      const y = this.row * BLOCK_SIZE;
      ctx.fillStyle = this.color;
      ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
      // inner highlight
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(x+4, y+4, BLOCK_SIZE-8, BLOCK_SIZE-8);
    }

    canMove(dx, dy) {
      const nc = this.col + dx;
      const nr = this.row + dy;
      if (nc < 0 || nc >= COLS) return false;
      if (nr < 0 || nr >= ROWS) return false;
      return !grid[nr][nc];
    }

    move(dx, dy) {
      if (this.canMove(dx, dy)) {
        this.col += dx;
        this.row += dy;
        return true;
      }
      return false;
    }

    hardDrop() {
      while (this.move(0,1)) {}
      // now landed
    }

    land() {
      grid[this.row][this.col] = OCCUPIED_COLOR;
    }
  }

  // current falling block
  let current = spawnBlock();
  function spawnBlock() {
    // If spawn position is blocked -> game over (clear grid)
    const c = Math.floor(Math.random() * COLS);
    if (grid[0][c]) {
      // Simple reset behavior
      for (let r=0;r<ROWS;r++) for (let c2=0;c2<COLS;c2++) grid[r][c2] = null;
    }
    return new Block(c, 0, BLOCK_COLOR);
  }

  // ----- Input handling -----
  const keys = { left:false, right:false, down:false };
  let lastMoveTime = 0;

  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'ArrowDown') keys.down = true;
    if (e.code === 'Space') {
      // hard drop
      current.hardDrop();
      current.land();
      clearFullRows();
      current = spawnBlock();
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
    if (e.code === 'ArrowDown') keys.down = false;
  });

  // ----- Row clearing (optional) -----
  function clearFullRows() {
    for (let r = ROWS-1; r >= 0; r--) {
      if (grid[r].every(cell => cell)) {
        // remove row r
        grid.splice(r, 1);
        // add empty row at top
        grid.unshift(Array.from({length:COLS}, ()=>null));
        // after clearing, stay at same r to check new row
        r++;
      }
    }
  }

  // ----- Drawing helpers -----
  function drawGridLines() {
    ctx.strokeStyle = GRID_LINE_COLOR;
    ctx.lineWidth = 1;
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        ctx.strokeRect(c*BLOCK_SIZE, r*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      }
    }
  }

  function drawOccupied() {
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        if (grid[r][c]) {
          ctx.fillStyle = grid[r][c];
          ctx.fillRect(c*BLOCK_SIZE, r*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }
    }
  }

  // ----- Game loop / timing -----
  let lastFall = performance.now();
  function gameLoop(now) {
    const delta = now - lastFall;
    const interval = keys.down ? FAST_FALL_INTERVAL : FALL_INTERVAL;

    // handle lateral moves with cooldown
    if (now - lastMoveTime > MOVE_COOLDOWN) {
      if (keys.left) {
        current.move(-1,0);
        lastMoveTime = now;
      } else if (keys.right) {
        current.move(1,0);
        lastMoveTime = now;
      }
    }

    if (delta >= interval) {
      lastFall = now;
      // try to move down
      const moved = current.move(0,1);
      if (!moved) {
        // landed
        current.land();
        clearFullRows();
        current = spawnBlock();
      }
    }

    // render
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGridLines();
    drawOccupied();
    current.draw();

    requestAnimationFrame(gameLoop);
  }

  // start
  requestAnimationFrame(gameLoop);

  // ----- Optional: simple keyboard instructions in console -----
  console.log("Falling Blocks ready. Use Arrow keys and Space.");
  </script>
</body>
</html>
